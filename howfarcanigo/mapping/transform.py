import numpy as np
from sklearn.cluster import DBSCAN
from geomath import hulls

"""
This module contains transformations to be performed on the coordinates
    generated by the main program.

These functions will take the list of data from the API (destination coordinates,
    travel times), and generate hull arrays which can be plotted
"""

def group_coords(lats_, lngs_, travel_times_, cutoff_mins_):
    """
    Group destination coordinates by the time taken to travel to them.

    Coordinates are separated by travel times. For a provided set of cutoff times, 
    split coordinates into buckets.

    Args:
        lats_ (list): destination latitudes
        lngs_ (list): destination longitudes
        travel_times_ (list): travel time to each destination coordinate
        cutoff_mins_ (list): upper limit of cut-off group

    Returns:
        (dict): Cutoff-times as keys with list of coordinates as values
    """

    def _make_dict_cumulative(dictionary_):
        """
        Make a dictionary of key (int), value (list) pairs cumulative

        Args:
            dictionary_ (dict): integer as key with list for each value

        Returns:
            (dict): each key containing list with all previous keys
        """
        for key in dictionary_.keys():
            original_key = key
            while key > min(dictionary_.keys()):
                key -= 1
                try:
                    dictionary_[original_key] = np.concatenate((dictionary_[original_key], dictionary_[key]))
                except:
                    pass # may not necessarily be one less key
        return dictionary_

    # convert seconds to minutes for travel time
    travel_times_mins = [round(i/60, 1) for i in travel_times_]
    # bin the data
    inds = np.digitize(travel_times_mins, np.array(cutoff_mins_))
    # initialise an empty dictionary
    ttime_dict = dict.fromkeys(np.unique(inds))

    # numpy array of lats and lngs together
    # hulls takes in longitude as the first element, latitude as the second element!!
    lng_lat = np.asarray(list(zip(lngs_, lats_)))
    for ind in np.unique(inds):
        # find indices of each bin, and apply a mask
        bin_mask = np.where(inds==ind)[0]
        bin_lng_lat = lng_lat[bin_mask]
        ttime_dict[ind] = bin_lng_lat

    return _make_dict_cumulative(ttime_dict)


def cluster_points(points, max_distance=np.sqrt(2*0.003**2)): #points list e.g. binned_coords[3]
    """
    Clusters points into islands

    Uses the DBSCAN algorithm to group points based on nearest neighbours

    Args:
        points (list): coordinate pairs, e.g. a set of binned coordinates
        max_distance (double): maximum distance beyond which two points will no longer be grouped

    Returns:
        (dict): keys identifying islands with values as lists where each list is a separate cluster of points
    """
    clustering = DBSCAN(eps=max_distance, min_samples=1).fit(points)
    # points labelled as -1 have no cluster
    assert len(clustering.labels_) == len(points)
    #plt.scatter(points[:,0], points[:,1], c=clustering.labels_, cmap='bwr')
    # initialise dictionary of empty lists
    islands = {i: [] for i in set(clustering.labels_)}
    # group clustered coordinates by label
    for index in range(len(points)):
        islands[clustering.labels_[index]].append(points[index])
    # change each grouping to a numpy array so that points can use slicing etc.
    for key in islands.keys():
        islands[key] = np.asarray(islands[key])
    return islands

def generate_hull_arrays(b_coords, num_bins=-1):
    """
    Generate hull arrays for each island in each cutoff time

    Args:
        b_coords (dict): cumulative dictionary of points belonging to each travel-time set of islands
            returned from the group_coords function
        num_bins (int): the number of bins that we want to process, if not all. Defaults to all bins

    Returns:
        (list): list with each element being a list describing the hull array
    """
    rng = np.random.RandomState(42) # initialise random state to generate points later
    bins = list(b_coords.keys()) # make dict keys in a list so we don't have to process them all
    if num_bins == -1: num_bins = max(bins)
    cutoff_hull_arrays = [] # initialise empty array to store all hull arrays for this cut off time
    print('\nGenerating hull arrays...')
    for key in bins[0:num_bins]: # take a certain number of bins 
        print('Processing island: ', key, ' of ', num_bins)
        islands = cluster_points(b_coords[key])
        island_hull_arrays = [] # initialise empty array to store all hull arrays for this island
        for point_set in islands.keys():
            print('\t Processing cluster {} of {}'.format(point_set+1, len(islands.keys())))
            if point_set == -1:
                raise ValueError('POINT SET -1')
                continue
            if len(islands[point_set]) < 3: # need at least 3 points to make a hull array
                # generate two very close by points at random so that we can draw a concave hull
                extra_points = 3 - len(islands[point_set]) 
                temp_points = islands[point_set][0] + rng.rand(extra_points,2)*(10**-7) # this gives the nearby points a resolution of ~1m
                hull_array = hulls.ConcaveHull(np.append(islands[point_set], temp_points).reshape((3, 2))).calculate() # append new points and reshape to correct size
            else:
                hull_array = hulls.ConcaveHull(islands[point_set]).calculate()
            island_hull_arrays.append(hull_array)
        cutoff_hull_arrays.append(island_hull_arrays)
    return cutoff_hull_arrays

def describe_cutoffs(cutoff_mins, binned_coords):
    """
    FUTURE:: Do we want to remove this and just keep it in main?
        Show the cumulative number of points at each cut off time

    Args:
        binned_coords (dict): travel time indices with coordinates attached to them
        cutoff_mins (list): minutes for the travel times we are interest up to

    Returns:
        None
    """
    print('Number of values associated with each cut-off time:')
    for val in range(1,len(cutoff_mins)):
        try:
            print('Cutoff time: ', cutoff_mins[val], ', Number of points: ', len(binned_coords[val]))
        except: pass

if __name__ == '__main__':
    pass